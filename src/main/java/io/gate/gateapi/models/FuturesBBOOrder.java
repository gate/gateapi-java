/*
 * Gate API
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.gate.gateapi.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

/**
 * contractBBOorderdetails
 */
public class FuturesBBOOrder {
    public static final String SERIALIZED_NAME_CONTRACT = "contract";
    @SerializedName(SERIALIZED_NAME_CONTRACT)
    private String contract;

    public static final String SERIALIZED_NAME_SIZE = "size";
    @SerializedName(SERIALIZED_NAME_SIZE)
    private Long size;

    public static final String SERIALIZED_NAME_DIRECTION = "direction";
    @SerializedName(SERIALIZED_NAME_DIRECTION)
    private String direction;

    public static final String SERIALIZED_NAME_ICEBERG = "iceberg";
    @SerializedName(SERIALIZED_NAME_ICEBERG)
    private Long iceberg;

    public static final String SERIALIZED_NAME_LEVEL = "level";
    @SerializedName(SERIALIZED_NAME_LEVEL)
    private Long level;

    public static final String SERIALIZED_NAME_CLOSE = "close";
    @SerializedName(SERIALIZED_NAME_CLOSE)
    private Boolean close = false;

    public static final String SERIALIZED_NAME_IS_CLOSE = "is_close";
    @SerializedName(SERIALIZED_NAME_IS_CLOSE)
    private Boolean isClose;

    public static final String SERIALIZED_NAME_REDUCE_ONLY = "reduce_only";
    @SerializedName(SERIALIZED_NAME_REDUCE_ONLY)
    private Boolean reduceOnly = false;

    public static final String SERIALIZED_NAME_IS_REDUCE_ONLY = "is_reduce_only";
    @SerializedName(SERIALIZED_NAME_IS_REDUCE_ONLY)
    private Boolean isReduceOnly;

    public static final String SERIALIZED_NAME_IS_LIQ = "is_liq";
    @SerializedName(SERIALIZED_NAME_IS_LIQ)
    private Boolean isLiq;

    /**
     * Time in force  - gtc: GoodTillCancelled - ioc: ImmediateOrCancelled, taker only - poc: PendingOrCancelled, makes a post-only order that always enjoys a maker fee - fok: FillOrKill, fill either completely or none
     */
    @JsonAdapter(TifEnum.Adapter.class)
    public enum TifEnum {
        GTC("gtc"),
        
        IOC("ioc"),
        
        POC("poc"),
        
        FOK("fok");

        private String value;

        TifEnum(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        public static TifEnum fromValue(String value) {
            for (TifEnum b : TifEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }

        public static class Adapter extends TypeAdapter<TifEnum> {
            @Override
            public void write(final JsonWriter jsonWriter, final TifEnum enumeration) throws IOException {
                jsonWriter.value(enumeration.getValue());
            }

            @Override
            public TifEnum read(final JsonReader jsonReader) throws IOException {
                String value =  jsonReader.nextString();
                return TifEnum.fromValue(value);
            }
        }
    }

    public static final String SERIALIZED_NAME_TIF = "tif";
    @SerializedName(SERIALIZED_NAME_TIF)
    private TifEnum tif = TifEnum.GTC;

    public static final String SERIALIZED_NAME_LEFT = "left";
    @SerializedName(SERIALIZED_NAME_LEFT)
    private Long left;

    public static final String SERIALIZED_NAME_FILL_PRICE = "fill_price";
    @SerializedName(SERIALIZED_NAME_FILL_PRICE)
    private String fillPrice;

    public static final String SERIALIZED_NAME_TEXT = "text";
    @SerializedName(SERIALIZED_NAME_TEXT)
    private String text;

    public static final String SERIALIZED_NAME_TKFR = "tkfr";
    @SerializedName(SERIALIZED_NAME_TKFR)
    private String tkfr;

    public static final String SERIALIZED_NAME_MKFR = "mkfr";
    @SerializedName(SERIALIZED_NAME_MKFR)
    private String mkfr;

    public static final String SERIALIZED_NAME_REFU = "refu";
    @SerializedName(SERIALIZED_NAME_REFU)
    private Integer refu;

    /**
     * Set side to close dual-mode position. &#x60;close_long&#x60; closes the long side; while &#x60;close_short&#x60; the short one. Note &#x60;size&#x60; also needs to be set to 0
     */
    @JsonAdapter(AutoSizeEnum.Adapter.class)
    public enum AutoSizeEnum {
        LONG("close_long"),
        
        SHORT("close_short");

        private String value;

        AutoSizeEnum(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        public static AutoSizeEnum fromValue(String value) {
            for (AutoSizeEnum b : AutoSizeEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }

        public static class Adapter extends TypeAdapter<AutoSizeEnum> {
            @Override
            public void write(final JsonWriter jsonWriter, final AutoSizeEnum enumeration) throws IOException {
                jsonWriter.value(enumeration.getValue());
            }

            @Override
            public AutoSizeEnum read(final JsonReader jsonReader) throws IOException {
                String value =  jsonReader.nextString();
                return AutoSizeEnum.fromValue(value);
            }
        }
    }

    public static final String SERIALIZED_NAME_AUTO_SIZE = "auto_size";
    @SerializedName(SERIALIZED_NAME_AUTO_SIZE)
    private AutoSizeEnum autoSize;

    public static final String SERIALIZED_NAME_STP_ID = "stp_id";
    @SerializedName(SERIALIZED_NAME_STP_ID)
    private Integer stpId;

    /**
     * Self-Trading Prevention Action. Users can use this field to set self-trade prevention strategies  1. After users join the &#x60;STP Group&#x60;, they can pass &#x60;stp_act&#x60; to limit the user&#39;s self-trade prevention strategy. If &#x60;stp_act&#x60; is not passed, the default is &#x60;cn&#x60; strategy. 2. When the user does not join the &#x60;STP group&#x60;, an error will be returned when passing the &#x60;stp_act&#x60; parameter. 3. If the user did not use &#x60;stp_act&#x60; when placing the order, &#x60;stp_act&#x60; will return &#39;-&#39;  - cn: Cancel newest, cancel new orders and keep old ones - co: Cancel oldest, cancel old orders and keep new ones - cb: Cancel both, both old and new orders will be cancelled
     */
    @JsonAdapter(StpActEnum.Adapter.class)
    public enum StpActEnum {
        CO("co"),
        
        CN("cn"),
        
        CB("cb"),
        
        MINUS("-");

        private String value;

        StpActEnum(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        public static StpActEnum fromValue(String value) {
            for (StpActEnum b : StpActEnum.values()) {
                if (b.value.equals(value)) {
                    return b;
                }
            }
            throw new IllegalArgumentException("Unexpected value '" + value + "'");
        }

        public static class Adapter extends TypeAdapter<StpActEnum> {
            @Override
            public void write(final JsonWriter jsonWriter, final StpActEnum enumeration) throws IOException {
                jsonWriter.value(enumeration.getValue());
            }

            @Override
            public StpActEnum read(final JsonReader jsonReader) throws IOException {
                String value =  jsonReader.nextString();
                return StpActEnum.fromValue(value);
            }
        }
    }

    public static final String SERIALIZED_NAME_STP_ACT = "stp_act";
    @SerializedName(SERIALIZED_NAME_STP_ACT)
    private StpActEnum stpAct;

    public static final String SERIALIZED_NAME_AMEND_TEXT = "amend_text";
    @SerializedName(SERIALIZED_NAME_AMEND_TEXT)
    private String amendText;

    public static final String SERIALIZED_NAME_LIMIT_VIP = "limit_vip";
    @SerializedName(SERIALIZED_NAME_LIMIT_VIP)
    private Long limitVip;

    public static final String SERIALIZED_NAME_PID = "pid";
    @SerializedName(SERIALIZED_NAME_PID)
    private Long pid;


    public FuturesBBOOrder contract(String contract) {
        
        this.contract = contract;
        return this;
    }

     /**
     * Futures contract
     * @return contract
    **/
    public String getContract() {
        return contract;
    }


    public void setContract(String contract) {
        this.contract = contract;
    }

    public FuturesBBOOrder size(Long size) {
        
        this.size = size;
        return this;
    }

     /**
     * Required. Trading quantity. Positive for buy, negative for sell. Set to 0 for close position orders.
     * @return size
    **/
    public Long getSize() {
        return size;
    }


    public void setSize(Long size) {
        this.size = size;
    }

    public FuturesBBOOrder direction(String direction) {
        
        this.direction = direction;
        return this;
    }

     /**
     * Direction: &#39;sell&#39; fetches the bid side, &#39;buy&#39; fetches the ask side.
     * @return direction
    **/
    public String getDirection() {
        return direction;
    }


    public void setDirection(String direction) {
        this.direction = direction;
    }

    public FuturesBBOOrder iceberg(Long iceberg) {
        
        this.iceberg = iceberg;
        return this;
    }

     /**
     * Display size for iceberg orders. 0 for non-iceberg orders. Note that hidden portions are charged taker fees.
     * @return iceberg
    **/
    @javax.annotation.Nullable
    public Long getIceberg() {
        return iceberg;
    }


    public void setIceberg(Long iceberg) {
        this.iceberg = iceberg;
    }

    public FuturesBBOOrder level(Long level) {
        
        this.level = level;
        return this;
    }

     /**
     * Level: maximum 20 levels
     * @return level
    **/
    public Long getLevel() {
        return level;
    }


    public void setLevel(Long level) {
        this.level = level;
    }

    public FuturesBBOOrder close(Boolean close) {
        
        this.close = close;
        return this;
    }

     /**
     * Set as &#x60;true&#x60; to close the position, with &#x60;size&#x60; set to 0
     * @return close
    **/
    @javax.annotation.Nullable
    public Boolean getClose() {
        return close;
    }


    public void setClose(Boolean close) {
        this.close = close;
    }

     /**
     * Is the order to close position
     * @return isClose
    **/
    @javax.annotation.Nullable
    public Boolean getIsClose() {
        return isClose;
    }


    public FuturesBBOOrder reduceOnly(Boolean reduceOnly) {
        
        this.reduceOnly = reduceOnly;
        return this;
    }

     /**
     * Set as &#x60;true&#x60; to be reduce-only order
     * @return reduceOnly
    **/
    @javax.annotation.Nullable
    public Boolean getReduceOnly() {
        return reduceOnly;
    }


    public void setReduceOnly(Boolean reduceOnly) {
        this.reduceOnly = reduceOnly;
    }

     /**
     * Is the order reduce-only
     * @return isReduceOnly
    **/
    @javax.annotation.Nullable
    public Boolean getIsReduceOnly() {
        return isReduceOnly;
    }


     /**
     * Is the order for liquidation
     * @return isLiq
    **/
    @javax.annotation.Nullable
    public Boolean getIsLiq() {
        return isLiq;
    }


    public FuturesBBOOrder tif(TifEnum tif) {
        
        this.tif = tif;
        return this;
    }

     /**
     * Time in force  - gtc: GoodTillCancelled - ioc: ImmediateOrCancelled, taker only - poc: PendingOrCancelled, makes a post-only order that always enjoys a maker fee - fok: FillOrKill, fill either completely or none
     * @return tif
    **/
    @javax.annotation.Nullable
    public TifEnum getTif() {
        return tif;
    }


    public void setTif(TifEnum tif) {
        this.tif = tif;
    }

     /**
     * Unfilled quantity
     * @return left
    **/
    @javax.annotation.Nullable
    public Long getLeft() {
        return left;
    }


     /**
     * Fill price
     * @return fillPrice
    **/
    @javax.annotation.Nullable
    public String getFillPrice() {
        return fillPrice;
    }


    public FuturesBBOOrder text(String text) {
        
        this.text = text;
        return this;
    }

     /**
     * Custom order information. If not empty, must follow the rules below:  1. Prefixed with &#x60;t-&#x60; 2. No longer than 28 bytes without &#x60;t-&#x60; prefix 3. Can only include 0-9, A-Z, a-z, underscore(_), hyphen(-) or dot(.)  In addition to user-defined information, the following are internal reserved fields that identify the order source:  - web: Web - api: API call - app: Mobile app - auto_deleveraging: Automatic deleveraging - liquidation: Forced liquidation of positions under the old classic mode - liq-xxx: a. Forced liquidation of positions under the new classic mode, including isolated margin, one-way cross margin, and non-hedged positions under two-way cross margin. b. Forced liquidation of isolated positions under the unified account single-currency margin mode - hedge-liq-xxx: Forced liquidation of hedged positions under the new classic mode two-way cross margin, i.e., simultaneously closing long and short positions - pm_liquidate: Forced liquidation under unified account multi-currency margin mode - comb_margin_liquidate: Forced liquidation under unified account portfolio margin mode - scm_liquidate: Forced liquidation of positions under unified account single-currency margin mode - insurance: Insurance
     * @return text
    **/
    @javax.annotation.Nullable
    public String getText() {
        return text;
    }


    public void setText(String text) {
        this.text = text;
    }

     /**
     * Taker fee
     * @return tkfr
    **/
    @javax.annotation.Nullable
    public String getTkfr() {
        return tkfr;
    }


     /**
     * Maker fee
     * @return mkfr
    **/
    @javax.annotation.Nullable
    public String getMkfr() {
        return mkfr;
    }


     /**
     * Referrer user ID
     * @return refu
    **/
    @javax.annotation.Nullable
    public Integer getRefu() {
        return refu;
    }


    public FuturesBBOOrder autoSize(AutoSizeEnum autoSize) {
        
        this.autoSize = autoSize;
        return this;
    }

     /**
     * Set side to close dual-mode position. &#x60;close_long&#x60; closes the long side; while &#x60;close_short&#x60; the short one. Note &#x60;size&#x60; also needs to be set to 0
     * @return autoSize
    **/
    @javax.annotation.Nullable
    public AutoSizeEnum getAutoSize() {
        return autoSize;
    }


    public void setAutoSize(AutoSizeEnum autoSize) {
        this.autoSize = autoSize;
    }

     /**
     * Orders between users in the same &#x60;stp_id&#x60; group are not allowed to be self-traded  1. If the &#x60;stp_id&#x60; of two orders being matched is non-zero and equal, they will not be executed. Instead, the corresponding strategy will be executed based on the &#x60;stp_act&#x60; of the taker. 2. &#x60;stp_id&#x60; returns &#x60;0&#x60; by default for orders that have not been set for &#x60;STP group&#x60;
     * @return stpId
    **/
    @javax.annotation.Nullable
    public Integer getStpId() {
        return stpId;
    }


    public FuturesBBOOrder stpAct(StpActEnum stpAct) {
        
        this.stpAct = stpAct;
        return this;
    }

     /**
     * Self-Trading Prevention Action. Users can use this field to set self-trade prevention strategies  1. After users join the &#x60;STP Group&#x60;, they can pass &#x60;stp_act&#x60; to limit the user&#39;s self-trade prevention strategy. If &#x60;stp_act&#x60; is not passed, the default is &#x60;cn&#x60; strategy. 2. When the user does not join the &#x60;STP group&#x60;, an error will be returned when passing the &#x60;stp_act&#x60; parameter. 3. If the user did not use &#x60;stp_act&#x60; when placing the order, &#x60;stp_act&#x60; will return &#39;-&#39;  - cn: Cancel newest, cancel new orders and keep old ones - co: Cancel oldest, cancel old orders and keep new ones - cb: Cancel both, both old and new orders will be cancelled
     * @return stpAct
    **/
    @javax.annotation.Nullable
    public StpActEnum getStpAct() {
        return stpAct;
    }


    public void setStpAct(StpActEnum stpAct) {
        this.stpAct = stpAct;
    }

     /**
     * The custom data that the user remarked when amending the order
     * @return amendText
    **/
    @javax.annotation.Nullable
    public String getAmendText() {
        return amendText;
    }


    public FuturesBBOOrder limitVip(Long limitVip) {
        
        this.limitVip = limitVip;
        return this;
    }

     /**
     * Counterparty user&#39;s VIP level for limit order fills. Current order will only match with orders whose VIP level is less than or equal to the specified level. Only 11~16 are supported; default is 0
     * @return limitVip
    **/
    @javax.annotation.Nullable
    public Long getLimitVip() {
        return limitVip;
    }


    public void setLimitVip(Long limitVip) {
        this.limitVip = limitVip;
    }

    public FuturesBBOOrder pid(Long pid) {
        
        this.pid = pid;
        return this;
    }

     /**
     * Position ID
     * @return pid
    **/
    @javax.annotation.Nullable
    public Long getPid() {
        return pid;
    }


    public void setPid(Long pid) {
        this.pid = pid;
    }
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        FuturesBBOOrder futuresBBOOrder = (FuturesBBOOrder) o;
        return Objects.equals(this.contract, futuresBBOOrder.contract) &&
                Objects.equals(this.size, futuresBBOOrder.size) &&
                Objects.equals(this.direction, futuresBBOOrder.direction) &&
                Objects.equals(this.iceberg, futuresBBOOrder.iceberg) &&
                Objects.equals(this.level, futuresBBOOrder.level) &&
                Objects.equals(this.close, futuresBBOOrder.close) &&
                Objects.equals(this.isClose, futuresBBOOrder.isClose) &&
                Objects.equals(this.reduceOnly, futuresBBOOrder.reduceOnly) &&
                Objects.equals(this.isReduceOnly, futuresBBOOrder.isReduceOnly) &&
                Objects.equals(this.isLiq, futuresBBOOrder.isLiq) &&
                Objects.equals(this.tif, futuresBBOOrder.tif) &&
                Objects.equals(this.left, futuresBBOOrder.left) &&
                Objects.equals(this.fillPrice, futuresBBOOrder.fillPrice) &&
                Objects.equals(this.text, futuresBBOOrder.text) &&
                Objects.equals(this.tkfr, futuresBBOOrder.tkfr) &&
                Objects.equals(this.mkfr, futuresBBOOrder.mkfr) &&
                Objects.equals(this.refu, futuresBBOOrder.refu) &&
                Objects.equals(this.autoSize, futuresBBOOrder.autoSize) &&
                Objects.equals(this.stpId, futuresBBOOrder.stpId) &&
                Objects.equals(this.stpAct, futuresBBOOrder.stpAct) &&
                Objects.equals(this.amendText, futuresBBOOrder.amendText) &&
                Objects.equals(this.limitVip, futuresBBOOrder.limitVip) &&
                Objects.equals(this.pid, futuresBBOOrder.pid);
    }

    @Override
    public int hashCode() {
        return Objects.hash(contract, size, direction, iceberg, level, close, isClose, reduceOnly, isReduceOnly, isLiq, tif, left, fillPrice, text, tkfr, mkfr, refu, autoSize, stpId, stpAct, amendText, limitVip, pid);
    }


    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class FuturesBBOOrder {\n");
        sb.append("      contract: ").append(toIndentedString(contract)).append("\n");
        sb.append("      size: ").append(toIndentedString(size)).append("\n");
        sb.append("      direction: ").append(toIndentedString(direction)).append("\n");
        sb.append("      iceberg: ").append(toIndentedString(iceberg)).append("\n");
        sb.append("      level: ").append(toIndentedString(level)).append("\n");
        sb.append("      close: ").append(toIndentedString(close)).append("\n");
        sb.append("      isClose: ").append(toIndentedString(isClose)).append("\n");
        sb.append("      reduceOnly: ").append(toIndentedString(reduceOnly)).append("\n");
        sb.append("      isReduceOnly: ").append(toIndentedString(isReduceOnly)).append("\n");
        sb.append("      isLiq: ").append(toIndentedString(isLiq)).append("\n");
        sb.append("      tif: ").append(toIndentedString(tif)).append("\n");
        sb.append("      left: ").append(toIndentedString(left)).append("\n");
        sb.append("      fillPrice: ").append(toIndentedString(fillPrice)).append("\n");
        sb.append("      text: ").append(toIndentedString(text)).append("\n");
        sb.append("      tkfr: ").append(toIndentedString(tkfr)).append("\n");
        sb.append("      mkfr: ").append(toIndentedString(mkfr)).append("\n");
        sb.append("      refu: ").append(toIndentedString(refu)).append("\n");
        sb.append("      autoSize: ").append(toIndentedString(autoSize)).append("\n");
        sb.append("      stpId: ").append(toIndentedString(stpId)).append("\n");
        sb.append("      stpAct: ").append(toIndentedString(stpAct)).append("\n");
        sb.append("      amendText: ").append(toIndentedString(amendText)).append("\n");
        sb.append("      limitVip: ").append(toIndentedString(limitVip)).append("\n");
        sb.append("      pid: ").append(toIndentedString(pid)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n        ");
    }

}

